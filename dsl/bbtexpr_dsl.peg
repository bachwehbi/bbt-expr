{
  var bbtCondition = require('./condition.js');
  var types = require('./types.js');
  var moment = require('moment');
  var Geolib = require('geolib');
  var mathjs = require('mathjs');
}

start
  = c_condition:OrExpression { return c_condition; }
  / Additive:Additive {return Additive;}

OrExpression
  = left:AndExpression right:(OR ws exp:OrExpression {return exp;})? {
    if (right) {
      return bbtCondition.createExpressionOrValue({
        left: left,
        right: right,
        oper: types.OPERATORS.BBT_OR
      })
    } else {
      return left;
    }
  }

AndExpression
  = left:atom right:(AND ws exp:AndExpression {return exp})? {
    if (right) {
      return bbtCondition.createExpressionOrValue({
        left: left,
        right: right,
        oper: types.OPERATORS.BBT_AND
      })
    } else {
      return left
    }
  }

atom
  = ws '(' ws exp:OrExpression ws ')' ws {
    return exp;
  }
  / NOT ws atom:atom {
    return bbtCondition.createExpressionOrValue({
      left: atom,
      oper: types.OPERATORS.BBT_NOT
    })
  }
  / Comparison:Comparison ws {
    return Comparison;
  }

ComparisonOperator
  = "==" {return types.OPERATORS.BBT_EQ}
  / "!=" {return types.OPERATORS.BBT_NEQ}
  / ">" {return types.OPERATORS.BBT_GT}
  / ">=" {return types.OPERATORS.BBT_GTE}
  / "<" {return types.OPERATORS.BBT_LT}
  / "<=" {return types.OPERATORS.BBT_LTQ}

Comparison
  = left:Additive ws oper:ComparisonOperator ws right:Additive {
    return bbtCondition.createExpressionOrValue({
      left: left,
      right: right,
      oper: oper
    })
  }

AdditiveOperator
  = "+" {return types.OPERATORS.BBT_ADD}
  / "-" {return types.OPERATORS.BBT_SUB}

Additive
  = left:Multiplicative  ws oper:AdditiveOperator  ws right:Additive {
    return bbtCondition.createExpressionOrValue({
      left: left,
      right: right,
      oper: oper
    })
  }
  / Multiplicative

MultiplicativeOperator
  = "*" { return types.OPERATORS.BBT_MULT }
  / "/" { return types.OPERATORS.BBT_DIV }
  / "idiv" { return types.OPERATORS.BBT_IDIV }
  / "%" { return types.OPERATORS.BBT_MOD }

Multiplicative
  = left:generic_value  ws oper:MultiplicativeOperator  ws right:Multiplicative {
    return bbtCondition.createExpressionOrValue({
      left: left,
      right: right,
      oper: oper
    })
  }
  / generic_value

generic_value =
  fct:fct keys:keys+ {

    if (fct.keys) {
      fct.keys.concat(keys)
    } else {
      fct.keys = keys;
    }

    return new bbtCondition.FunctionValue(fct)
  }
  / fct:fct {
    return new bbtCondition.FunctionValue(fct)
  }
  / NestedValue

NestedValue
  = value:value keys:keys? {
    if (value.keys) {
      value.keys.concat(keys)
    } else {
      value.keys = keys;
    }

    return value;
  }

fct =
  value:value keys:keys+ '(' params:ParameterList? ')'
    {
      var operation = keys.pop()

      if (value.keys) {
        value.keys.concat(keys)
      } else {
        value.keys = keys;
      }

      return {
        fct: function() {
          var self = this
          return self[operation].apply(self, arguments)
        },
        params: params,
        that: value
      };
    }

  / prot:prototype operation:operation '(' params:ParameterList? ')'
    {
      if (typeof prot[operation] !== 'function') {
        throw prot.name + ' has no method ' + operation;
      }
      return {
        fct: prot[operation],
        params: params
      };
    }

value =
  OPEN_PARENTHESE  ws Additive:Additive ws CLOSE_PARENTHESE {
    return Additive
  }
  / primitive:primitive {
    return new bbtCondition.Value({
      val: primitive
    })
  }
  / constructor:constructor {return constructor;}
  / trigger:trigger {return new bbtCondition.TriggerValue()}
  / resource:resource
  {
    return new bbtCondition.ResourceValue(resource);
  }


resource = channel:STNAME "." resource:STNAME {
  return {
    channel: channel,
    resource: resource
    }
  }

trigger = TRIGGER

operation = key

keys =
  key+

key =
  "." elem:STNAME {return elem;}

ParameterList
  = param:Parameter params:(',' parameter:Parameter {return parameter;})* {
    if (params.length) {
      params.unshift(param);
      return params
    } else {
      return [param];
    }
  }


Parameter =
  ws param:Additive ws {return param;}

prototype =
  STRING {return String.prototype;}
  / DATE {return moment.prototype;}
  / GEOLIB {return Geolib.prototype;}
  / MATH {return mathjs;}

constructor =
  dateconstructor:date_constructor {return dateconstructor;}
  / gps:geopoint {return gps;}
  / poly:polygone {return poly;}

date_constructor =
  DATE "(" params:ParameterList? ")"
    {
      return new bbtCondition.FunctionValue({
        fct: function() {
          var bound = moment.bind();
          var retval = bound.apply(undefined, arguments)
          console.log(retval.format())
          return retval
        },
        params: params
      });
    }

geopoint =
  ws GEOPOINT OPEN_PARENTHESE lat:Parameter ws ',' ws lng:Parameter CLOSE_PARENTHESE
    {
      return new bbtCondition.FunctionValue({
        fct: function(latitude, longitude) {
          return {latitude: latitude, longitude: longitude}
        },
        params: [lat, lng]
      });
      return
    }
  / ws GEOPOINT OPEN_PARENTHESE parameter:Parameter ws CLOSE_PARENTHESE
    {
      return new bbtCondition.FunctionValue({
        fct: function(param) {
          // we are expecting param to contain latitude and longitude
          if (!param.hasOwnProperty('latitude') || param.hasOwnProperty('longitude')) {
            throw new Error('Expecting param to have latitude and longitude parameters')
          }

          return {latitude: param.latitude, longitude: param.longitude}
        },
        params: [parameter]
      });
      return
    }


polygone
  = ws POLYGONE OPEN_PARENTHESE p1:geopoint ',' p2:geopoint points:(',' point:geopoint {return point;})+ CLOSE_PARENTHESE {
    points.unshift(p1, p2)
    return new bbtCondition.FunctionValue({
      fct: function(pts) {
        return Array.prototype.slice.call(arguments);
      },
      params: points
    });
  }

primitive
  = str:string {return str;}
  / nb:number {return nb;}
  / b:bool {return b;}

bool
  = "true" {return true;}
  / "false" {return false;}

OR
  = "OR"i /* case insensitive */
  / "||"

AND
  = "AND"i /* case insensitive */
  / "&&"

NOT
  = "NOT" /* case insensitive */
  / '!'

OPEN_PARENTHESE = '('
CLOSE_PARENTHESE = ')'

STRING = "String"
DATE = "Date"
GEOLIB = "Geolib"
GEOPOINT = "Geopoint"
POLYGONE = "Polygone"
MATH = "Math"
TRIGGER = "trigger"i

STNAME = char:[a-zA-Z_] chars:[0-9a-zA-Z_]* { return char + chars.join(""); }

string "string" =
  '"' chars:chars '"' { return chars; }
  / STRING OPEN_PARENTHESE value:primitive CLOSE_PARENTHESE
    {
      return String(value)
    }

chars
  = chars:char+ { return chars.join(""); }

char
  // In the original JSON grammar:
  // "any-Unicode-character-except-"-or-\-or-control-character"
  = [^"\\\0-\x1F\x7f]
  / '\\"'  { return '"';  }
  / "\\\\" { return "\\"; }
  / "\\/"  { return "/";  }
  / "\\b"  { return "\b"; }
  / "\\f"  { return "\f"; }
  / "\\n"  { return "\n"; }
  / "\\r"  { return "\r"; }
  / "\\t"  { return "\t"; }
  / "\\u" digits:$(hexDigit hexDigit hexDigit hexDigit) {
      return String.fromCharCode(parseInt(digits, 16));
    }

hexDigit
  = [0-9a-fA-F]

number
  = sign:("-" {return true})? nb:int fraction:('.' dec:int {return dec})? {
    var value = parseFloat(nb + '.' + fraction);
    if(sign) return -value;
    return value;
  }

int
  = nb:digit+ {return parseInt(nb.join(""));}

digit
  = [0-9]

/* ===== Whitespace ===== */

nl = newline*
newline = [\r\n]

ws "space" = space*
space = [ \t]

_ "whitespace"
  = whitespace*

// Whitespace is undefined in the original JSON grammar, so I assume a simple
// conventional definition consistent with ECMA-262, 5th ed.
whitespace
  = [ \t\r\n]
